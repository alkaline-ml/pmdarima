diff --git a/pmdarima/arima/arima.py b/pmdarima/arima/arima.py
index e7649e21..1bc3597f 100644
--- a/pmdarima/arima/arima.py
+++ b/pmdarima/arima/arima.py
@@ -12,6 +12,7 @@ from statsmodels import api as sm
 
 from scipy.stats import gaussian_kde, norm
 import numpy as np
+import numpy.polynomial.polynomial as np_polynomial
 import warnings
 
 from . import _validation as val
@@ -23,14 +24,66 @@ from ..compat import matplotlib as mpl_compat
 from ..compat import pmdarima as pm_compat
 from ..utils import if_has_delegate, is_iterable, check_endog, check_exog
 from ..utils.visualization import _get_plt
+from ..utils.array import diff_inv, diff
 
 # Get the version
 import pmdarima
 
 __all__ = [
-    'ARIMA'
+    'ARIMA',
+    'ARMAtoMA'
 ]
 
+def ARMAtoMA(ar, ma, max_deg):
+    """Convert ARMA coefficients to infinite MA coefficients.
+
+    Compute coefficients of MA model equivalent to given ARMA model.
+    MA coefficients are cut off at max_deg.
+    The same function as ARMAtoMA() in stats library of R
+
+    ARMA model is defined as
+    x_t - ar_1*x_{t-1} - ar_2*x_{t-2} - ... - ar_p*x_{t-p}
+        = e_t + ma_1*e_{t-1} + ma_2*e_{t-2} + ... + ma_q*e_{t-q}
+    namely
+    (1 - \Sum_{i=1~p}[ar_i*B^i]) x_t = (1 + \Sum_{i=1~q}[ma_i*B^i]) e_t
+
+    Equivalent MA model is
+        x_t = (1 - \Sum_{i=1~p}[ar_i*B^i])^{-1} (1 + \Sum_{i=1~q}[ma_i*B^i]) e_t
+        = (1 + \Sum_{i=1}[ema_i*B^i]) e_t
+    where ema_i is a coefficient of equivalent MA model. The ema_i satisfies
+        (1 - \Sum_{i=1~p}[ar_i*B^i]) * (1 + \Sum_{i=1}[ema_i*B^i]) = 1 + \Sum_{i=1~q}[ma_i*B^i]
+    thus
+        \Sum_{i=1}[ema_i*B^i] = \Sum_{i=1~p}[ar_i*B^i] + \Sum_{i=1~p}[ar_i*B^i] * \Sum_{j=1}[ema_j*B^j] + \Sum_{i=1~q}[ma_i*B^i]
+    therefore
+        ema_i = ar_i(but 0 if i>p) + \Sum_{j=1~min(i-1,p)}[ar_j*ema_{i-j}] + ma_i(but 0 if i>q)
+              = \Sum_{j=1~min(i,p)}[ar_j*ema_{i-j}(but 1 if j=i)] + ma_i(but 0 if i>q)
+
+    Parameters
+    ----------
+    ar_coeffs : array-like, shape=(AR order p)
+        The array of AR coefficients
+
+    ma_coeffs : array-like, shape=(MA order q)
+        The array of MA coefficients
+
+    max_deg : int
+        Coefficients are computed up to the order of max_deg
+
+    Returns
+    -------
+    res : np.ndarray, shape=(max_deg)
+        Equivalent MA coefficients
+    """
+    p = len(ar)
+    q = len(ma)
+    ema = np.empty(max_deg)
+    for i in range(0, max_deg):
+        temp = ma[i] if i < q else 0.0
+        for j in range(0, min(i+1, p)):
+            temp += ar[j] * (ema[i-j-1] if i-j-1 >= 0 else 1.0)
+        ema[i] = temp
+    return ema
+
 
 def _aicc(model_results, nobs, add_constant):
     """Compute the corrected Akaike Information Criterion"""
@@ -84,6 +137,45 @@ def _seasonal_prediction_with_confidence(arima_res,
 
     f = results.predicted_mean
     conf_int = results.conf_int(alpha=alpha)
+    if arima_res.specification['simple_differencing']:
+        # if simple_differencing == True, statemodels.get_prediction returns
+        # mid and confidence intervals on differenced time series.
+        # we have to invert differencing the mid and confidence intervals
+        y_org = arima_res.model.orig_endog
+        d = arima_res.model.orig_k_diff
+        D = arima_res.model.orig_k_seasonal_diff
+        period = arima_res.model.seasonal_periods
+        # Forecast mid: undifferencing non-seasonal part
+        if d > 0:
+            y_seasonal_diff = y_org if D == 0 else diff(y_org, lag = period, differences = D)
+            f_temp = np.append(y_seasonal_diff[-d:], f)
+            f_temp = diff_inv(f_temp, lag = 1, differences = d)
+            f = f_temp[(2*d):]
+        # Forecast mid: undifferencing seasonal part
+        if D > 0 and period > 1:
+            f_temp = np.append(y_org[-(D*period):], f)
+            f_temp = diff_inv(f_temp, lag = period, differences = D)
+            f = f_temp[(2*D*period):]
+        # confidence interval
+        ar_poly = arima_res.polynomial_reduced_ar
+        poly_simple_diff = np_polynomial.polypow(np.array([1., -1.]), d)
+        unit_seasonal_diff = np.zeros(period + 1); unit_seasonal_diff[0] = 1.; unit_seasonal_diff[-1] = 1.
+        poly_seasonal_diff = np_polynomial.polypow(unit_seasonal_diff, D)
+        ar = -np.polymul(ar_poly, np.polymul(poly_simple_diff, poly_seasonal_diff))[1:]
+        ma = arima_res.polynomial_reduced_ma[1:]
+        n_predMinus1 = end - start
+        ema =  ARMAtoMA(ar, ma, n_predMinus1)
+        sigma2 = arima_res._params_variance[0]
+        var = np.cumsum(np.append(1., ema * ema)) * sigma2
+        if arima_res.use_t:
+            q = results.dist.ppf(1.-alpha/2,results.dist_args)
+        else:
+            q = results.dist.ppf(1.-alpha/2)
+        conf_int[:,0] = f - q * np.sqrt(var)
+        conf_int[:,1] = f + q * np.sqrt(var)
+
+        print("simple_differencing")
+
     return check_endog(f, dtype=None, copy=False), \
         check_array(conf_int, copy=False, dtype=None)
 
diff --git a/pmdarima/arima/tests/test_arima.py b/pmdarima/arima/tests/test_arima.py
index 7d5ac5f7..571b00ef 100644
--- a/pmdarima/arima/tests/test_arima.py
+++ b/pmdarima/arima/tests/test_arima.py
@@ -712,3 +712,11 @@ def test_update_1_iter(model):
 
     # They should be close
     assert np.allclose(params1, params2, atol=0.05)
+
+def test_ARMAtoMA():
+    ar = np.array([0.5, 0.6])
+    ma = np.array([0.4, 0.3, 0.1, 0.05])
+    max_deg = 10
+    equivalent_ma = arima_utils.ARMAtoMA(ar, ma, max_deg)
+    ema_expected = np.array([0.900000, 1.350000, 1.315000, 1.517500, 1.547750, 1.684375, 1.770837, 1.896044, 2.010524, 2.142888])
+    assert_array_almost_equal(equivalent_ma, ema_expected, decimal = 4)
diff --git a/pmdarima/arima/tests/test_auto.py b/pmdarima/arima/tests/test_auto.py
index 301ef37d..f0d62607 100644
--- a/pmdarima/arima/tests/test_auto.py
+++ b/pmdarima/arima/tests/test_auto.py
@@ -13,7 +13,7 @@ from pmdarima.arima.utils import nsdiffs
 from pmdarima.warnings import ModelFitWarning
 from pmdarima.compat.pytest import pytest_error_str, pytest_warning_messages
 
-from numpy.testing import assert_array_almost_equal
+from numpy.testing import assert_allclose
 
 import os
 from os.path import abspath, dirname
@@ -363,6 +363,46 @@ def test_stepwise_with_simple_differencing():
     assert simple.order == seasonal_fit.order
     assert simple.seasonal_order == seasonal_fit.seasonal_order
 
+def test_stepwise_with_simple_differencing2():
+    def do_fit(simple_differencing):
+        return pm.auto_arima(wineind, start_p=1, start_q=1, max_p=1,
+                             max_q=2, m=12, start_P=0,
+                             seasonal=True,
+                             d=1, D=1, stepwise=True,
+                             error_action='ignore',
+                             sarimax_kwargs={
+                                 'simple_differencing': simple_differencing
+                             },
+                             maxiter=2,
+                             trace=True)
+
+    # show that we can forecast even after the
+    # pickling (this was fit in parallel)
+    seasonal_fit = do_fit(False)
+    seasonal_fit.predict(n_periods=60)
+
+    # ensure summary still works
+    seasonal_fit.summary()
+
+    # Show we can predict on seasonal where conf_int is true
+    prediction = seasonal_fit.predict(n_periods=60, return_conf_int=True)
+    pred_mid = prediction[0]
+    pred_conf_int = prediction[1]
+    df_pred = pd.DataFrame(np.hstack((pred_mid[:,None],pred_conf_int[:,0][:,None],pred_conf_int[:,1][:,None])), columns=("mid", "CIleft", "CIright"))
+    df_pred.to_csv("prediction.csv")
+
+    # We should get the same order when simple_differencing
+    simple = do_fit(True)
+    prediction_simple = simple.predict(n_periods=60, return_conf_int=True)
+    pred_simple_mid = prediction_simple[0]
+    pred_simple_conf_int = prediction_simple[1]
+    df_pred_simple = pd.DataFrame(np.hstack((pred_simple_mid[:,None],pred_simple_conf_int[:,0][:,None],pred_simple_conf_int[:,1][:,None])), columns=("mid", "CIleft", "CIright"))
+    df_pred_simple.to_csv("prediction_simple.csv")
+    #assert simple.order == seasonal_fit.order
+    #assert simple.seasonal_order == seasonal_fit.seasonal_order
+    #assert_allclose(pred_mid, pred_simple_mid, rtol = 0.1)
+    #assert_allclose(pred_conf_int[:, 0], pred_conf_int[:, 1], rtol = 0.1)
+
 
 def test_with_seasonality2():
     # show we can estimate D even when it's not there...
diff --git a/pmdarima/arima/tests/test_utils.py b/pmdarima/arima/tests/test_utils.py
index ca44f3df..73f74759 100644
--- a/pmdarima/arima/tests/test_utils.py
+++ b/pmdarima/arima/tests/test_utils.py
@@ -5,6 +5,7 @@ import pytest
 
 from pmdarima.arima import utils as arima_utils
 from pmdarima.compat.pytest import pytest_warning_messages, pytest_error_str
+from numpy.testing import assert_array_almost_equal
 
 
 def test_issue_341():
@@ -32,3 +33,4 @@ def test_issue_351():
     warnings_messages = pytest_warning_messages(w_list)
     assert len(warnings_messages) == 1
     assert 'shorter than m' in warnings_messages[0]