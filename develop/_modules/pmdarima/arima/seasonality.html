

<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pmdarima.arima.seasonality &mdash; pmdarima 0.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/fields.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/gitcontrib.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../../',
              VERSION:'0.0.0',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> pmdarima
          

          
          </a>

          
            
            
              <div class="version">
                0.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/classes.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../user_guide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../whats_new.html">What's New?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rfc/index.html">RFCs</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">pmdarima</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>pmdarima.arima.seasonality</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pmdarima.arima.seasonality</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#</span>
<span class="c1"># Author: Taylor Smith &lt;taylor.smith@alkaline-ml.com&gt;</span>
<span class="c1">#</span>
<span class="c1"># Tests for seasonal differencing terms, and seasonal decomposition</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">make_pipeline</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>

<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">svd</span>
<span class="kn">from</span> <span class="nn">statsmodels</span> <span class="kn">import</span> <span class="n">api</span> <span class="k">as</span> <span class="n">sm</span>
<span class="kn">from</span> <span class="nn">statsmodels.tools</span> <span class="kn">import</span> <span class="n">add_constant</span>

<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">solve</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.arima</span> <span class="kn">import</span> <span class="n">_aicc</span>
<span class="kn">from</span> <span class="nn">..compat.numpy</span> <span class="kn">import</span> <span class="n">DTYPE</span>
<span class="kn">from</span> <span class="nn">.stationarity</span> <span class="kn">import</span> <span class="n">_BaseStationarityTest</span>
<span class="kn">from</span> <span class="nn">..utils.array</span> <span class="kn">import</span> <span class="n">c</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">check_endog</span>

<span class="kn">from</span> <span class="nn">._arima</span> <span class="kn">import</span> <span class="n">C_canova_hansen_sd_test</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;CHTest&#39;</span><span class="p">,</span>
    <span class="s1">&#39;decompose&#39;</span><span class="p">,</span>
    <span class="s1">&#39;OCSBTest&#39;</span>
<span class="p">]</span>


<div class="viewcode-block" id="decompose"><a class="viewcode-back" href="../../../modules/generated/pmdarima.arima.decompose.html#pmdarima.arima.decompose">[docs]</a><span class="k">def</span> <span class="nf">decompose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">type_</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">filter_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decompose the time series into trend, seasonal, and random components.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : np.array, shape=(n_samples,)</span>
<span class="sd">        The time series of which the trend, seasonal, and noise/random</span>
<span class="sd">        components will be extracted.</span>

<span class="sd">    type_: str</span>
<span class="sd">        The type of decomposition that will be performed - &#39;multiplicative&#39; or</span>
<span class="sd">        &#39;additive&#39;. We would use &#39;multiplicative&#39; generally when we see an</span>
<span class="sd">        increasing trend. We use &#39;additive&#39; when the trend is relatively</span>
<span class="sd">        stable over time.</span>

<span class="sd">    m: int</span>
<span class="sd">        The frequency in terms of number of observations. This behaves</span>
<span class="sd">        similarly to R&#39;s frequency for a time series (ts).</span>

<span class="sd">    filter_: np.array, optional (default=None)</span>
<span class="sd">        A filter by which the convolution will be performed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    decomposed_tuple : namedtuple</span>
<span class="sd">        A named tuple with ``x``, ``trend``, ``seasonal``, and ``random``</span>
<span class="sd">        components where ``x`` is the input signal, ``trend`` is the overall</span>
<span class="sd">        trend, ``seasonal`` is the seasonal component, and `random` is the</span>
<span class="sd">        noisy component. The input signal ``x`` can be mostly reconstructed by</span>
<span class="sd">        the other three components with a number of points missing equal to</span>
<span class="sd">        ``m``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is generally used in conjunction with</span>
<span class="sd">    :func:`pmdarima.utils.visualization.decomposed_plot`,</span>
<span class="sd">    which plots the decomposed components. Also there is an example script in</span>
<span class="sd">    the ``examples`` folder of the repo and the ``Examples`` section of the</span>
<span class="sd">    docs as well.</span>

<span class="sd">     References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Example of decompose using both multiplicative and additive types:</span>
<span class="sd">           https://anomaly.io/seasonal-trend-decomposition-in-r/index.html</span>

<span class="sd">    .. [2] R documentation for decompose:</span>
<span class="sd">           https://www.rdocumentation.org/packages/stats/versions/3.6.1/topics/decompose</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="n">multiplicative</span> <span class="o">=</span> <span class="s2">&quot;multiplicative&quot;</span>
    <span class="n">additive</span> <span class="o">=</span> <span class="s2">&quot;additive&quot;</span>
    <span class="n">is_m_odd</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Helper function to stay consistent and concise based on &#39;type_&#39;</span>
    <span class="k">def</span> <span class="nf">_decomposer_helper</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">type_</span> <span class="o">==</span> <span class="n">multiplicative</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span>

    <span class="c1"># Since R&#39;s ts class has a frequency as input I think this it acceptable</span>
    <span class="c1"># to ask the user for the frequency.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">1</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;f&#39; should be a positive integer&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">filter_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">filter_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">m</span><span class="p">,))</span> <span class="o">/</span> <span class="n">m</span>

    <span class="c1"># We only accept the values in multiplicative or additive</span>
    <span class="k">if</span> <span class="n">type_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">multiplicative</span><span class="p">,</span> <span class="n">additive</span><span class="p">):</span>
        <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;type_&#39; can only take values &#39;</span><span class="si">{}</span><span class="s2">&#39; or &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">multiplicative</span><span class="p">,</span> <span class="n">additive</span><span class="p">))</span>

    <span class="c1"># There needs to be at least 2 periods. This is due to the behavior of</span>
    <span class="c1"># convolutions and how they behave with respect to losing endpoints</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">m</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;time series has no or less than 2 periods&quot;</span><span class="p">)</span>

    <span class="c1"># Take half of m for the convolution / sma process.</span>
    <span class="n">half_m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">trend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">filter_</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_m_odd</span><span class="p">:</span>
        <span class="n">trend</span> <span class="o">=</span> <span class="n">trend</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># we remove the final index if m is even.</span>

    <span class="c1"># Remove the effect of the trend on the original signal and pad for reshape</span>
    <span class="n">sma_xs</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">half_m</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">trend</span><span class="p">)</span> <span class="o">+</span> <span class="n">half_m</span><span class="p">)</span>
    <span class="n">detrend</span> <span class="o">=</span> <span class="n">_decomposer_helper</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">sma_xs</span><span class="p">],</span> <span class="n">trend</span><span class="p">)</span>
    <span class="n">num_seasons</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">trend</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">pad_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_seasons</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span> <span class="o">-</span> <span class="n">trend</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">pad_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">buffer</span> <span class="o">=</span> <span class="n">pad_length</span> <span class="o">*</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span>
        <span class="n">detrend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">detrend</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="n">buffer</span><span class="p">)</span>

    <span class="c1"># Determine the seasonal effect of the signal</span>
    <span class="n">m_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">detrend</span><span class="p">,</span> <span class="p">(</span><span class="n">num_seasons</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>
    <span class="n">seasonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">m_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">seasonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">seasonal</span><span class="p">[</span><span class="n">half_m</span><span class="p">:]</span> <span class="o">+</span> <span class="n">seasonal</span><span class="p">[:</span><span class="n">half_m</span><span class="p">])</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">seasonal</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">seasonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">seasonal</span><span class="p">,</span> <span class="n">temp</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">pad_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">seasonal</span> <span class="o">=</span> <span class="n">seasonal</span><span class="p">[:</span><span class="o">-</span><span class="n">pad_length</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">is_m_odd</span><span class="p">:</span>
        <span class="n">seasonal</span> <span class="o">=</span> <span class="n">seasonal</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># We buffer the trend and seasonal components so that they are the same</span>
    <span class="c1"># length as the other outputs. This counters the effects of losing data</span>
    <span class="c1"># by the convolution/sma</span>
    <span class="n">buffer</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="o">*</span> <span class="n">half_m</span>
    <span class="n">trend</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">buffer</span> <span class="o">+</span> <span class="n">trend</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="n">buffer</span><span class="p">)</span>

    <span class="c1"># Remove the trend and seasonal effects from the original signal to get</span>
    <span class="c1"># the random/noisy effects within the original signal.</span>
    <span class="n">random</span> <span class="o">=</span> <span class="n">_decomposer_helper</span><span class="p">(</span><span class="n">_decomposer_helper</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">trend</span><span class="p">),</span> <span class="n">seasonal</span><span class="p">)</span>

    <span class="c1"># Create a namedtuple so the output mirrors the output of the R function.</span>
    <span class="n">decomposed</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;decomposed&#39;</span><span class="p">,</span> <span class="s1">&#39;x trend seasonal random&#39;</span><span class="p">)</span>
    <span class="n">decomposed_tuple</span> <span class="o">=</span> <span class="n">decomposed</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">trend</span><span class="p">,</span> <span class="n">seasonal</span><span class="p">,</span> <span class="n">random</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">decomposed_tuple</span></div>


<span class="k">class</span> <span class="nc">_SeasonalStationarityTest</span><span class="p">(</span><span class="n">_BaseStationarityTest</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Provides the base class for seasonal differencing tests such as the</span>
<span class="sd">    Canova-Hansen test and the Osborn-Chui-Smith-Birchenhall tests. These tests</span>
<span class="sd">    are used to determine the seasonal differencing term for a time-series.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="n">m</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;m must be &gt; 1&#39;</span><span class="p">)</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">estimate_seasonal_differencing_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate the seasonal differencing term.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like, shape=(n_samples,)</span>
<span class="sd">            The time series vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>


<div class="viewcode-block" id="CHTest"><a class="viewcode-back" href="../../../modules/generated/pmdarima.arima.CHTest.html#pmdarima.arima.CHTest">[docs]</a><span class="k">class</span> <span class="nc">CHTest</span><span class="p">(</span><span class="n">_SeasonalStationarityTest</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Conduct a CH test for seasonality.</span>

<span class="sd">    The Canova-Hansen test for seasonal differences. Canova and Hansen</span>
<span class="sd">    (1995) proposed a test statistic for the null hypothesis that the seasonal</span>
<span class="sd">    pattern is stable. The test statistic can be formulated in terms of</span>
<span class="sd">    seasonal dummies or seasonal cycles. The former allows us to identify</span>
<span class="sd">    seasons (e.g. months or quarters) that are not stable, while the latter</span>
<span class="sd">    tests the stability of seasonal cycles (e.g. cycles of period 2 and 4</span>
<span class="sd">    quarters in quarterly data). [1]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : int</span>
<span class="sd">        The seasonal differencing term. For monthly data, e.g., this would be</span>
<span class="sd">        12. For quarterly, 4, etc. For the Canova-Hansen test to work,</span>
<span class="sd">        ``m`` must exceed 1.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This test is generally not used directly, but in conjunction with</span>
<span class="sd">    :func:`pmdarima.arima.nsdiffs`, which directly estimates the number</span>
<span class="sd">    of seasonal differences.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Testing for seasonal stability using the Canova</span>
<span class="sd">           and Hansen test statisic: http://bit.ly/2wKkrZo</span>

<span class="sd">    .. [2] R source code for CH test:</span>
<span class="sd">           https://github.com/robjhyndman/forecast/blob/master/R/arima.R#L148</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">crit_vals</span> <span class="o">=</span> <span class="n">c</span><span class="p">(</span><span class="mf">0.4617146</span><span class="p">,</span> <span class="mf">0.7479655</span><span class="p">,</span> <span class="mf">1.0007818</span><span class="p">,</span>
                  <span class="mf">1.2375350</span><span class="p">,</span> <span class="mf">1.4625240</span><span class="p">,</span> <span class="mf">1.6920200</span><span class="p">,</span>
                  <span class="mf">1.9043096</span><span class="p">,</span> <span class="mf">2.1169602</span><span class="p">,</span> <span class="mf">2.3268562</span><span class="p">,</span>
                  <span class="mf">2.5406922</span><span class="p">,</span> <span class="mf">2.7391007</span><span class="p">)</span>

<div class="viewcode-block" id="CHTest.__init__"><a class="viewcode-back" href="../../../modules/generated/pmdarima.arima.CHTest.html#pmdarima.arima.CHTest.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CHTest</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_sd_test</span><span class="p">(</span><span class="n">wts</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="c1"># assume no NaN values since called internally</span>
        <span class="c1"># also assume s &gt; 1 since called internally</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">wts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># no use checking, because this is an internal method</span>
        <span class="c1"># if n &lt;= s:  raise ValueError(&#39;too few samples (%i&lt;=%i)&#39; % (n, s))</span>
        <span class="n">frec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">int</span><span class="p">((</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">ltrunc</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="p">((</span><span class="n">n</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.25</span><span class="p">)))</span>
        <span class="n">R1</span> <span class="o">=</span> <span class="n">CHTest</span><span class="o">.</span><span class="n">_seas_dummy</span><span class="p">(</span><span class="n">wts</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

        <span class="c1"># fit model, get residuals</span>
        <span class="n">lmch</span> <span class="o">=</span> <span class="n">make_pipeline</span><span class="p">(</span>
            <span class="n">StandardScaler</span><span class="p">(</span><span class="n">with_mean</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">LinearRegression</span><span class="p">()</span>
        <span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">wts</span><span class="p">)</span>
        <span class="c1"># lmch = sm.OLS(wts, R1).fit(method=&#39;qr&#39;)</span>
        <span class="n">residuals</span> <span class="o">=</span> <span class="n">wts</span> <span class="o">-</span> <span class="n">lmch</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">R1</span><span class="p">)</span>

        <span class="c1"># translated R code:</span>
        <span class="c1"># multiply the residuals by the column vectors</span>
        <span class="c1"># Fhataux = Fhat.copy()</span>
        <span class="c1"># for i in range(Fhat.shape[1]):  # for (i in 1:(s-1))</span>
        <span class="c1">#     Fhataux[:, i] = R1[:, i] * residuals</span>

        <span class="c1"># more efficient numpy:</span>
        <span class="n">Fhataux</span> <span class="o">=</span> <span class="p">(</span><span class="n">R1</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">residuals</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># translated R code</span>
        <span class="c1"># matrix row cumsums</span>
        <span class="c1"># Fhat = np.ones((n, s - 1)) * np.nan</span>
        <span class="c1"># for i in range(n):</span>
        <span class="c1">#    for n in range(Fhataux.shape[1]):</span>
        <span class="c1">#         Fhat[i, n] = Fhataux[:i, n].sum()</span>

        <span class="c1"># more efficient numpy:</span>
        <span class="n">Ne</span> <span class="o">=</span> <span class="n">Fhataux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># As of v0.9.1, use the C_canova_hansen_sd_test function to compute</span>
        <span class="c1"># Omnw, Omfhat, A, frecob. This avoids the overhead of multiple calls</span>
        <span class="c1"># to C functions</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">AtOmfhatA</span> <span class="o">=</span> <span class="n">C_canova_hansen_sd_test</span><span class="p">(</span><span class="n">ltrunc</span><span class="p">,</span> <span class="n">Ne</span><span class="p">,</span> <span class="n">Fhataux</span><span class="p">,</span> <span class="n">frec</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

        <span class="c1"># UPDATE 01/04/2018 - we can get away without computing u, v</span>
        <span class="c1"># (this is also MUCH MUCH faster!!!)</span>
        <span class="n">sv</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">AtOmfhatA</span><span class="p">,</span> <span class="n">compute_uv</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># type: np.ndarray</span>

        <span class="c1"># From R:</span>
        <span class="c1"># double.eps: the smallest positive floating-point number ‘x’ such that</span>
        <span class="c1"># ‘1 + x != 1’.  It equals ‘double.base ^ ulp.digits’ if either</span>
        <span class="c1"># ‘double.base’ is 2 or ‘double.rounding’ is 0; otherwise, it</span>
        <span class="c1"># is ‘(double.base ^ double.ulp.digits) / 2’.  Normally</span>
        <span class="c1"># ‘2.220446e-16’.</span>
        <span class="c1"># Numpy&#39;s float64 has an eps of 2.2204460492503131e-16</span>
        <span class="k">if</span> <span class="n">sv</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">sv</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">:</span>  <span class="c1"># machine min eps</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># solve against the identity matrix, then produce</span>
        <span class="c1"># a nasty mess of dot products... this is the (horrendous) R code:</span>
        <span class="c1"># (1/N^2) * sum(diag(solve(tmp) %*% t(A) %*% t(Fhat) %*% Fhat %*% A))</span>
        <span class="c1"># https://github.com/robjhyndman/forecast/blob/master/R/arima.R#L321</span>
        <span class="n">Fhat</span> <span class="o">=</span> <span class="n">Fhataux</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">solved</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">AtOmfhatA</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">AtOmfhatA</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">n</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">solved</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
            <span class="n">Fhat</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Fhat</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_seas_dummy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="c1"># Here is the R code:</span>
        <span class="c1"># (https://github.com/robjhyndman/forecast/blob/master/R/arima.R#L132)</span>
        <span class="c1">#</span>
        <span class="c1"># SeasDummy &lt;- function(x) {</span>
        <span class="c1">#   n &lt;- length(x)</span>
        <span class="c1">#   m &lt;- frequency(x)</span>
        <span class="c1">#   if (m == 1) {</span>
        <span class="c1">#     stop(&quot;Non-seasonal data&quot;)</span>
        <span class="c1">#   }</span>
        <span class="c1">#   tt &lt;- 1:n</span>
        <span class="c1">#   fmat &lt;- matrix(NA, nrow = n, ncol = 2 * m)</span>
        <span class="c1">#   for (i in 1:m) {</span>
        <span class="c1">#     fmat[, 2 * i] &lt;- sin(2 * pi * i * tt / m)</span>
        <span class="c1">#     fmat[, 2 * (i - 1) + 1] &lt;- cos(2 * pi * i * tt / m)</span>
        <span class="c1">#   }</span>
        <span class="c1">#   return(fmat[, 1:(m - 1)])</span>
        <span class="c1"># }</span>
        <span class="c1"># set up seasonal dummies using fourier series</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># assume m &gt; 1 since this function called internally...</span>
        <span class="k">assert</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;This function is called internally and &#39;</span> \
                      <span class="s1">&#39;should not encounter this issue&#39;</span>

        <span class="n">tt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">fmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">m</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># for(i in 1:m)</span>
            <span class="c1"># subtract one, unlike the R code. in the R code, this sets</span>
            <span class="c1"># columns 2, 4, 6, etc... here it sets 1, 3, 5</span>
            <span class="c1"># fmat[,2*i] &lt;- sin(2*pi*i*tt/m)</span>
            <span class="n">fmat</span><span class="p">[:,</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">i</span> <span class="o">*</span> <span class="n">tt</span> <span class="o">/</span> <span class="n">m</span><span class="p">)</span>

            <span class="c1"># in the R code, this sets columns 1, 3, 5, etc. here it</span>
            <span class="c1"># sets 0, 2, 4, etc.</span>
            <span class="c1"># fmat[,2*(i-1)+1] &lt;- cos(2*pi*i*tt/m)</span>
            <span class="n">fmat</span><span class="p">[:,</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">i</span> <span class="o">*</span> <span class="n">tt</span> <span class="o">/</span> <span class="n">m</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fmat</span><span class="p">[:,</span> <span class="p">:</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

<div class="viewcode-block" id="CHTest.estimate_seasonal_differencing_term"><a class="viewcode-back" href="../../../modules/generated/pmdarima.arima.CHTest.html#pmdarima.arima.CHTest.estimate_seasonal_differencing_term">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_seasonal_differencing_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate the seasonal differencing term.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like, shape=(n_samples,)</span>
<span class="sd">            The time series vector.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        D : int</span>
<span class="sd">            The seasonal differencing term. The CH test defines a set of</span>
<span class="sd">            critical values::</span>

<span class="sd">                (0.4617146, 0.7479655, 1.0007818,</span>
<span class="sd">                 1.2375350, 1.4625240, 1.6920200,</span>
<span class="sd">                 1.9043096, 2.1169602, 2.3268562,</span>
<span class="sd">                 2.5406922, 2.7391007)</span>

<span class="sd">            For different values of ``m``, the CH statistic is compared</span>
<span class="sd">            to a different critical value, and returns 1 if the computed</span>
<span class="sd">            statistic is greater than the critical value, or 0 if not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_case</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># ensure vector</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">check_endog</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">DTYPE</span><span class="p">,</span> <span class="n">preserve_series</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">chstat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sd_test</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="mi">12</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">chstat</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">crit_vals</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span>  <span class="c1"># R does m - 1...</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">24</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">chstat</span> <span class="o">&gt;</span> <span class="mf">5.098624</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">52</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">chstat</span> <span class="o">&gt;</span> <span class="mf">10.341416</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">365</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">chstat</span> <span class="o">&gt;</span> <span class="mf">65.44445</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">chstat</span> <span class="o">&gt;</span> <span class="mf">0.269</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span> <span class="o">**</span> <span class="mf">0.928</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="OCSBTest"><a class="viewcode-back" href="../../../modules/generated/pmdarima.arima.OCSBTest.html#pmdarima.arima.OCSBTest">[docs]</a><span class="k">class</span> <span class="nc">OCSBTest</span><span class="p">(</span><span class="n">_SeasonalStationarityTest</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform an OCSB test of seasonality.</span>

<span class="sd">    Compute the Osborn, Chui, Smith, and Birchenhall (OCSB) test for an input</span>
<span class="sd">    time series to determine whether it needs seasonal differencing. The</span>
<span class="sd">    regression equation may include lags of the dependent variable. When</span>
<span class="sd">    ``lag_method`` = &quot;fixed&quot;, the lag order is fixed to ``max_lag``; otherwise,</span>
<span class="sd">    ``max_lag`` is the maximum number of lags considered in a lag selection</span>
<span class="sd">    procedure that minimizes the ``lag_method`` criterion, which can be</span>
<span class="sd">    &quot;aic&quot;, &quot;bic&quot; or corrected AIC, &quot;aicc&quot;.</span>

<span class="sd">    Critical values for the test are based on simulations, which have been</span>
<span class="sd">    smoothed over to produce critical values for all seasonal periods</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : int</span>
<span class="sd">        The seasonal differencing term. For monthly data, e.g., this would be</span>
<span class="sd">        12. For quarterly, 4, etc. For the OCSB test to work, ``m`` must</span>
<span class="sd">        exceed 1.</span>

<span class="sd">    lag_method : str, optional (default=&quot;aic&quot;)</span>
<span class="sd">        The lag method to use. One of (&quot;fixed&quot;, &quot;aic&quot;, &quot;bic&quot;, &quot;aicc&quot;). The</span>
<span class="sd">        metric for assessing model performance after fitting a linear model.</span>

<span class="sd">    max_lag : int, optional (default=3)</span>
<span class="sd">        The maximum lag order to be considered by ``lag_method``.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Osborn DR, Chui APL, Smith J, and Birchenhall CR (1988)</span>
<span class="sd">           &quot;Seasonality and the order of integration for consumption&quot;,</span>
<span class="sd">           Oxford Bulletin of Economics and Statistics 50(4):361-377.</span>

<span class="sd">    .. [2] R&#39;s forecast::OCSB test source code: https://bit.ly/2QYQHno</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_ic_method_map</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;aic&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">fit</span><span class="p">:</span> <span class="n">fit</span><span class="o">.</span><span class="n">aic</span><span class="p">,</span>
        <span class="s2">&quot;bic&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">fit</span><span class="p">:</span> <span class="n">fit</span><span class="o">.</span><span class="n">bic</span><span class="p">,</span>

        <span class="c1"># TODO: confirm False for add_constant, since the model fit contains</span>
        <span class="c1">#   . a constant term</span>
        <span class="s2">&quot;aicc&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">fit</span><span class="p">:</span> <span class="n">_aicc</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">nobs</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="p">}</span>

<div class="viewcode-block" id="OCSBTest.__init__"><a class="viewcode-back" href="../../../modules/generated/pmdarima.arima.OCSBTest.html#pmdarima.arima.OCSBTest.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">lag_method</span><span class="o">=</span><span class="s2">&quot;aic&quot;</span><span class="p">,</span> <span class="n">max_lag</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">OCSBTest</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lag_method</span> <span class="o">=</span> <span class="n">lag_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_lag</span> <span class="o">=</span> <span class="n">max_lag</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_calc_ocsb_crit_val</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the OCSB critical value&quot;&quot;&quot;</span>
        <span class="c1"># See:</span>
        <span class="c1"># https://github.com/robjhyndman/forecast/blob/</span>
        <span class="c1"># 8c6b63b1274b064c84d7514838b26dd0acb98aee/R/unitRoot.R#L409</span>
        <span class="n">log_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">0.2937411</span> <span class="o">*</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.2850853</span> <span class="o">*</span> <span class="p">(</span><span class="n">log_m</span> <span class="o">-</span> <span class="mf">0.7656451</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.05983644</span><span class="p">)</span> <span class="o">*</span>
                   <span class="p">((</span><span class="n">log_m</span> <span class="o">-</span> <span class="mf">0.7656451</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mf">1.652202</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_do_lag</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">lag</span><span class="p">,</span> <span class="n">omit_na</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform the TS lagging&quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">lag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Create a 2d array of dims (n + (lag - 1), lag). This looks cryptic..</span>
        <span class="c1"># If there are tons of lags, this may not be super efficient...</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span> <span class="o">+</span> <span class="p">(</span><span class="n">lag</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">lag</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lag</span><span class="p">):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>

        <span class="k">if</span> <span class="n">omit_na</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gen_lags</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">max_lag</span><span class="p">,</span> <span class="n">omit_na</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create the lagged exogenous array used to fit the linear model&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">max_lag</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># delegate down</span>
        <span class="k">return</span> <span class="n">OCSBTest</span><span class="o">.</span><span class="n">_do_lag</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">max_lag</span><span class="p">,</span> <span class="n">omit_na</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_fit_ocsb</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">lag</span><span class="p">,</span> <span class="n">max_lag</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit the linear model used to compute the test statistic&quot;&quot;&quot;</span>
        <span class="n">y_first_order_diff</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

        <span class="c1"># if there are no more samples, we have to bail</span>
        <span class="k">if</span> <span class="n">y_first_order_diff</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;There are no more samples after a first-order &quot;</span>
                <span class="s2">&quot;seasonal differencing. See http://alkaline-ml.com/pmdarima/&quot;</span>
                <span class="s2">&quot;seasonal-differencing-issues.html for a more in-depth &quot;</span>
                <span class="s2">&quot;explanation and potential work-arounds.&quot;</span>
            <span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">y_first_order_diff</span><span class="p">)</span>
        <span class="n">ylag</span> <span class="o">=</span> <span class="n">OCSBTest</span><span class="o">.</span><span class="n">_gen_lags</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">lag</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">max_lag</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># y = tail(y, -maxlag)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">max_lag</span><span class="p">:]</span>

        <span class="c1"># A constant term is added in the R code&#39;s lm formula. We do that in</span>
        <span class="c1"># the linear model&#39;s constructor</span>
        <span class="n">mf</span> <span class="o">=</span> <span class="n">ylag</span><span class="p">[:</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">ar_fit</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">OLS</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">add_constant</span><span class="p">(</span><span class="n">mf</span><span class="p">))</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;qr&#39;</span><span class="p">)</span>

        <span class="c1"># Create Z4</span>
        <span class="n">z4_y</span> <span class="o">=</span> <span class="n">y_first_order_diff</span><span class="p">[</span><span class="n">lag</span><span class="p">:]</span>  <span class="c1"># new endog</span>
        <span class="n">z4_lag</span> <span class="o">=</span> <span class="n">OCSBTest</span><span class="o">.</span><span class="n">_gen_lags</span><span class="p">(</span><span class="n">y_first_order_diff</span><span class="p">,</span> <span class="n">lag</span><span class="p">)[:</span><span class="n">z4_y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>
        <span class="n">z4_preds</span> <span class="o">=</span> <span class="n">ar_fit</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">add_constant</span><span class="p">(</span><span class="n">z4_lag</span><span class="p">))</span>  <span class="c1"># preds</span>
        <span class="n">z4</span> <span class="o">=</span> <span class="n">z4_y</span> <span class="o">-</span> <span class="n">z4_preds</span>  <span class="c1"># test residuals</span>

        <span class="c1"># Create Z5. Looks odd because y and lag depend on each other and go</span>
        <span class="c1"># back and forth for two stages</span>
        <span class="n">z5_y</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">z5_lag</span> <span class="o">=</span> <span class="n">OCSBTest</span><span class="o">.</span><span class="n">_gen_lags</span><span class="p">(</span><span class="n">z5_y</span><span class="p">,</span> <span class="n">lag</span><span class="p">)</span>
        <span class="n">z5_y</span> <span class="o">=</span> <span class="n">z5_y</span><span class="p">[</span><span class="n">lag</span><span class="p">:]</span>
        <span class="n">z5_lag</span> <span class="o">=</span> <span class="n">z5_lag</span><span class="p">[:</span><span class="n">z5_y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>
        <span class="n">z5_preds</span> <span class="o">=</span> <span class="n">ar_fit</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">add_constant</span><span class="p">(</span><span class="n">z5_lag</span><span class="p">))</span>
        <span class="n">z5</span> <span class="o">=</span> <span class="n">z5_y</span> <span class="o">-</span> <span class="n">z5_preds</span>

        <span class="c1"># Finally, fit a linear regression on mf with z4 &amp; z5 features added</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span>
            <span class="n">mf</span><span class="p">,</span>
            <span class="n">z4</span><span class="p">[:</span><span class="n">mf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">z5</span><span class="p">[:</span><span class="n">mf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">))</span>

        <span class="k">return</span> <span class="n">sm</span><span class="o">.</span><span class="n">OLS</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;qr&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compute_test_statistic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span>
        <span class="n">maxlag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_lag</span>
        <span class="n">method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lag_method</span>

        <span class="c1"># We might try multiple lags in this case</span>
        <span class="n">crit_regression</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">maxlag</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;fixed&#39;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">icfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ic_method_map</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; is an invalid method. Must be one &quot;</span>
                                 <span class="s2">&quot;of (&#39;aic&#39;, &#39;aicc&#39;, &#39;bic&#39;, &#39;fixed&#39;)&quot;</span><span class="p">)</span>

            <span class="n">fits</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">icvals</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">lag_term</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxlag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># 1 -&gt; maxlag (incl)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_ocsb</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">lag_term</span><span class="p">,</span> <span class="n">maxlag</span><span class="p">)</span>
                    <span class="n">fits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>
                    <span class="n">icvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">icfunc</span><span class="p">(</span><span class="n">fit</span><span class="p">))</span>
                <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>  <span class="c1"># Singular matrix</span>
                    <span class="n">icvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                    <span class="n">fits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

            <span class="c1"># If they&#39;re all NaN, raise</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">icvals</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All lag values up to &#39;maxlag&#39; produced &quot;</span>
                                 <span class="s2">&quot;singular matrices. Consider using a longer &quot;</span>
                                 <span class="s2">&quot;series, a different lag term or a different &quot;</span>
                                 <span class="s2">&quot;test.&quot;</span><span class="p">)</span>

            <span class="c1"># Compute the information criterion vals</span>
            <span class="n">best_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">icvals</span><span class="p">))</span>
            <span class="n">maxlag</span> <span class="o">=</span> <span class="n">best_index</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1"># Save this in case we can&#39;t compute a better one</span>
            <span class="n">crit_regression</span> <span class="o">=</span> <span class="n">fits</span><span class="p">[</span><span class="n">best_index</span><span class="p">]</span>

        <span class="c1"># Compute the actual linear model used for determining the test stat</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">regression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_ocsb</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">maxlag</span><span class="p">,</span> <span class="n">maxlag</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>  <span class="c1"># Singular matrix</span>
            <span class="k">if</span> <span class="n">crit_regression</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">regression</span> <span class="o">=</span> <span class="n">crit_regression</span>
            <span class="c1"># Otherwise we have no solution to fall back on</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not find a solution. Try a longer &quot;</span>
                                 <span class="s2">&quot;series, different lag term, or a different &quot;</span>
                                 <span class="s2">&quot;test.&quot;</span><span class="p">)</span>

        <span class="c1"># Get the coefficients for the z4 and z5 matrices</span>
        <span class="n">tvals</span> <span class="o">=</span> <span class="n">regression</span><span class="o">.</span><span class="n">tvalues</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>  <span class="c1"># len 2</span>
        <span class="k">return</span> <span class="n">tvals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># just z5, like R does it</span>

<div class="viewcode-block" id="OCSBTest.estimate_seasonal_differencing_term"><a class="viewcode-back" href="../../../modules/generated/pmdarima.arima.OCSBTest.html#pmdarima.arima.OCSBTest.estimate_seasonal_differencing_term">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_seasonal_differencing_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate the seasonal differencing term.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like, shape=(n_samples,)</span>
<span class="sd">            The time series vector.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        D : int</span>
<span class="sd">            The seasonal differencing term. For different values of ``m``,</span>
<span class="sd">            the OCSB statistic is compared to an estimated critical value, and</span>
<span class="sd">            returns 1 if the computed statistic is greater than the critical</span>
<span class="sd">            value, or 0 if not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_case</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># ensure vector</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">check_endog</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">DTYPE</span><span class="p">,</span> <span class="n">preserve_series</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Get the critical value for m</span>
        <span class="n">stat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_test_statistic</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">crit_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_ocsb_crit_val</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">stat</span> <span class="o">&gt;</span> <span class="n">crit_val</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2017-2022, Taylor G Smith

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>